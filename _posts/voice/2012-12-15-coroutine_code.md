---
layout: post
title: 设计一套coroutine
category: voice
---

## 从Goroutine想到

目前使用了一段时间的Go,发现这真的是一门好语言,各种特性基本满足了我对程序设计的各种需求,尤其是神奇的Goroutine,让并发变得非常容易,chan也让并发间的通信变得非常方便

不过先早Goroutine有一个大的缺点,就是调度问题.比如在某个goroutine,如果不调用会阻塞的系统调用的话,基本上是不会被中断的,跑到死就不会松开CPU,而其他Goroutine就会饿死了.

当然,这应该是我们程序设计上的bug,因为毕竟我们写的程序,如果明明有这种特殊情况,但我们没有处理而让程序hang在那里,这是我们的错.不过让Goroutine可以更好的调度,我觉得不论怎么说都是一件好事.

可惜的是,Go的大牛们已经将Goroutine定性了,说不会将Goroutine的调度做成像OS那样复杂和公平(当然,他们个个都有这样的实力),也就是说,这更进一步的要求了我们的开发能力,要给出合理的设计,避免这样的情况.

好吧,我知道大牛们是在用另一种方式鼓励我们提炼自己的设计,这是好事

## 可是...

话有两说,毕竟不是所有人都能搞的清设计,而且实现一个这样的调度器,至少对我这样一个挫人来说,是个很兴奋的事情,所以我还是决定尝试一下这个思路,在C中编写一个模块

这里列一下我认为应该实现的点:

1. 初期,实现一个高性能的coroutine,有基本的create,resume,yield功能,支持不定参数(和多值返回?这个我觉得应该试试)
2. 再次把coroutine扩展到多线程,当某个routine执行时间过长时,要不就直接suspend掉,或者创建新的线程执行等待的routine(这个属于调度策略了,先有框架,然后再谈具体策略)
3. 添加类似channel的东西,简化routine之间依赖参数值和yield进行同步的策略
4. 实现匿名函数(哈哈哈,我觉得目标越发的不可能了)

其实本质来看,就是结合用户级线程和系统级线程的综合体

估计我能实现第一个就很不错了,努力吧

ps: 之所以把这篇文章放到这里,就是因为我觉得不一定能实现;(

