---
layout: post
title: UnixV6分析(2) 中断/陷入/调用
category: code
tag: v6
---

## 题外话

真的很是惭愧,自从去年11月开始弄这个之后,已经过去五个月了,而这居然才仅仅是v6分析的第二篇文章.当然,工作生活比较忙确实是一个原因,但更为重要的是,做事情没有计划,东一下西一下,什么都搞,什么都落下.所以在指定了新的计划之后,我会每周更新一次源码分析的文章,先把v6搞定再说

好的,闲话休讲.

## 为什么讲这篇

硬件是OS内部比较复杂的一块,我们看到,很多讲内核开发的书,谈论的主要内容就是驱动,和硬件打交道的模块.除去硬件和同硬件交互的模块,剩下的就是我们的应用层面的事情了(当然,这是针对内核而言,不是我们普通的应用),不论是文件系统,调度还是输入输出等等,都可以看作是软件工作,它们固然很复杂,但是就已经脱离开硬件的层面了.

所以这就是这篇的目的,上一篇当中我们介绍了v6运行的环境--pdp11/40,这一篇我们讲和硬件的交互,中断/陷入

## 名词解释

* 中断: cpu外设产生的**信号**,有一定的优先级,等待cpu进行处理,可以被屏蔽
* 陷入: cpu内部产生的**信号**,无优先级,cpu一般立即处理,无法屏蔽(也可以认为优先级最高)
* 调用: 软件生成的**信号**,一般来说是**陷入**的一种,通常用来进行**系统调用**

之所以将这三个统一起来介绍,最主要的原因在于这三种本质上都是同cpu打交道(cpu是最重要的硬件,所以也算是驱动交互模块吧),通知cpu某些事情发生,等待cpu进行处理,而且这三个都是异步的,即不是事先安排好的调用顺序,是可能随时发生,随时处理的事件(其实想想,很类似我们GUI编程中的事件循环,cpu不停的idle中,直到有事件来,处理完后又回到idle).而且,这三个的处理在v6基本上是一个过程(其他os也类似),所以我就直接来总的说明了.

下文我就不每次都把三个名称都列出来了,大家意会.

## 补充说明

unixv6的汇编代码中大部分的数字都是用8进制表示的,10进制表示的符号会在数字末尾添加'.'符号以示区别,而本篇中默认的显示为10进制,8进制的数字我会按照常规,前面添加'0'以示区别.这点比较闹心,还望大家记清(v6汇编中使用8进制的原因见[前一篇][introduction])

## 相关指令一览

pdp-11/40有些指令同这三种交互有关,现在给予一个简单的介绍,通过后文对代码的描述,应该会有更彻底的了解

需要注意的是,我们这里讨论的是v6使用的汇编器的指令,可能和[pdp-11/40手册][pdp-11/40 manual]有所不同

* `br 1f`: 无条件相对跳转,有一定范围限制(-128~+127之间),一般我们只用标号来代替实际的相对位置(这个复杂工作交由汇编器处理),如本例,1f表示向下的第一个标号1位置,反之,1b表示向上的第一个标号1位置
* `jmp dst`: 无条件绝对跳转(pc=dst)
* `jsr reg, dst`: 这是我们使用最多的跳转,用来完成调用的,操作过程为1.reg入栈;2.reg=next(即reg保存了这条指令的下一条指令地址,也就是调用返回地址);3.jmp dst
* `rts reg`: 配合jsr完成调用的返回,操作过程为1.pc=reg(即reg保存了返回地址);2.reg=出栈内容.对比jsr,可以看到对称的一面
* `rtt`: 配合中断(中断都是将ps,pc依次入栈),操作为pc,ps依次出栈回复原值

### trap之谜

在v6中,有三个trap,是我们需要注意的(对,万恶的三个trap居然是一模一样的名字,谁起的啊)

1. 汇编指令trap: 1518行的代码即是汇编指令trap的一例,trap的icode从0104400到0104777,前八位固定,后八位是调用号,013表示第11号系统调用,即exec(参看2923行).很多时候,我们可以称之为'sys',因为trap指令唯一的用途就是进行系统调用
2. 汇编代码trap: 755行的代码就是trap的汇编程序,这个trap是作为一个入口来使用的,同下面(776行)的call一样,是为了给中断调用搭建环境的,因为毕竟我们不想在汇编完成复杂的处理逻辑,但中断调用时,cpu不会自动的建立c函数需要的堆栈环境,所以需要做个中间跳板
3. c函数trap: 2693行的代码就是c函数trap,这里完成了大多数调用逻辑,2中的汇编代码就是为了给这个函数提供环境,所以记住,这个trap函数并不普通,有一些神奇的特性(后文会看)

## 中断/陷入流程

中断/陷入的过程都是类似的,区别仅在于来源和优先级不一样(一个外,一个内;一个有,一个无),所以二者只在最开始有所不同

### 中断的前奏

外部硬件产生一个信号,发送到与之相连的总线,并接通到cpu的中断引脚上,此时,cpu会首先比较该中断优先级和当前优先级(ps的5-7位),如果当前优先级高,则忽略该中断,否则就进行处理

### 陷入的前奏

cpu内部产生一个信号(某些故障或者软件进行了系统调用),cpu马上进行无延迟的处理

注意,此处无延迟的处理并不是说我们写的某个系统调用一下子就被调用了,要知道,我们能控制的只是在进程内部使用了trap指令,但是什么时候cpu运行到进程的这一步,是有cpu进行调度的(这是后面的大问题),所以不要把调度和陷入混淆.(但是只要运行这个指令,就是无延迟的处理)

### 故事的后来

1. cpu将当前的ps,pc分别入当前栈.此处需要注意的是,pdp-11/40分两种模式,kernel和user,需要看清楚什么时候入kernel栈,什么时候入user栈.一般而言,内核自己处理的一般都是kernel栈,比如内核正在调度时,中断发生了,那么此时ps,pc就是入kernel栈;再比如用户进行系统调用的时候,就是入user栈
2. 从指定的中断向量中,依次得到pc,ps的新值.中断向量(trap vector)是事先约定好的,比如总线错误(bus error)就是1号,系统调用就是7号,中断向量的地址是中断向量号*4(每个中断向量为4B,2B的pc值,2B的ps值),比如总线错误的向量位置为4,系统调用的位置为28.大家可以从low.s(500-577有一个感性的认识)
3. pc有了新值,自然就执行新的命令,一般而言,执行的都是一个跳转指令,跳到入口的trap(755行)或者call(776行),给即将执行的c函数搭建环境.当然其中还有一些额外的检测处理,不多大致都是构建堆栈,填补参数,此处的参数不是我们真正的处理参数,而是交给trap或者对应硬件驱动处理函数的参数(我们仅介绍trap)
4. 从调用中返回,准备进行返回,进行调度检测(这个以后说),然后清理堆栈,恢复原来的pc和ps(使用rtt指令),执行完毕

### 总结

可以看到,流程还是比较简单的,代码除了有些绕之外,也是比较好理解的.

问题的关键在于我们如何设计一个通用的处理流程,而且还能针对不同的处理进行区分,这一点,我想,是这些trap设计的难点,也是下面要一一展开的.

## 代码分析





















[pdp-11/40 manual]: http://pdos.csail.mit.edu/6.828/2005/pdp11/index.html
[introduction]: /introduction_to_v6
