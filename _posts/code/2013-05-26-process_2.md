---
layout: post
title: UnixV6分析(4) 进程--进程启动与切换
category: code
tag: xv6
---

## 关于本篇

从本篇开始,我们就准备跳入C语言的世界了,在跳进去之前,我们需要把汇编的东东搞定.所以借着研究进程启动与切换,我们把剩下的大部分相关汇编介绍一遍.

当然,重点还是接着上一篇来讲os的启动入口函数main,并重点讲解新进程是怎么来的(当然,此处就是init进程怎么来的)和进程是怎么切换的(主进程和新的init)

## 分析汇编代码

代码脱离开使用情景,非常的让人迷惑,所以曾经我试图想在讲解main的时候讲解代码,但是总觉得没有搞清每个函数的作用,断然调入各种调用之间,很是迷惑

所以,我们这里先介绍以后使用到的各种函数,当然,我们首先简单介绍每个函数的使用场景,具体的参数/返回值和函数的作用,希望在分析的时候大家注意这点

### mfpi/mtpi

这两个不是函数,而是两条特殊汇编指令,用以提供模式之间的数据交互(还记得否,模式在PS的高4位,分为前模式和现模式,有两种值,kernel或者user),可以根据PS的值来进行对应的设置,甚至可以是同一个模式

* **mfpi**: 使用的格式为`mfpi d`,作用是将前模式的d(任意一个地址值或寄存器)中的内容压入当前栈
* **mtpi**: 使用的格式为`mtpi d`,作用是将从当前栈出栈,并把值赋值到前模式的d(任意一个地址值或寄存器)里

这两个指令不仅提供了不同模式之间数据的交互,同样可以以栈为中介,完成同一模式下的数据交互,我们可以在后面的具体使用中看到实例

### clearseg

clearseg的原型类似于`void clearseg(char *block_addr);`,参数是内存中某block的起始地址,作用是将本block的内容清零.一个block是32字,即64B大小

具体代码见676行:

    .globl _clearseg
    _clearseg:
        mov PS, -(sp)       / 保存原有的PS
        mov UISA0, -(sp)    / 保存原有的UISA0
        mov $30340, PS      / cur = kernel, prev = user, pri = 7
        mov 6(sp), UISA0    / UISA0 = block_addr
        mov UISD0, -(sp)    / 保存UISD0
        mov $6, UISD0       / acf = rw
        clr r0
        mov $32., r1        / num = 32
    1:
        clr -(sp)           / 0入栈
        mtpi (r0)+          / 0出栈,并赋值到r0
        sob r1, 1b
        mov (sp)+, UISD0    / 恢复原有值
        mov (sp)+, UISA0
        mov (sp)+, PS
        rts pc

clearseg其实就是把kernel栈的内容清零,然后把它出栈赋值到user空间的r0位置.此处,我们借用了user模式的S1作为kernel和user交互的窗口,一个字一个字(2B)的清零

### copyseg

copyseg的原型类似于`void copyseg(char *src, char *dst);`,参数是内存中两个block地址,作用是将src block的内容复制到dst block中.

具体见695行:

    .globl _copyseg
    _copyseg:
        mov PS, -(sp)       / 保存原有值
        mov UISA0, -(sp)
        mov UISA1, -(sp)
        mov $30340, PS      / cur = kernel, prev = user, pri = 7
        mov 10(sp), UISA0   / UISA0 = src
        mov 12(sp), UISA1   / UISA1 = dst
        mov UISD0, -(sp)
        mov UISD1, -(sp)
        mov $6, UISD0       / acf = rw
        mov $6, UISD1       / acf = rw
        mov r2, -(sp)
        clr r0              / r0从0开始,对应S0
        mov $8192., r1      / r1从8K开始,对应S1
        mov $32., r2
    1:
        mfpi (r0)+          / 从S0取,即从src取
        mtpi (r1)+          / 复制到S1,即复制到dst
        sob r2, 1b
        mov (sp)+, r2       / 恢复
        mov (sp)+, UISD1
        mov (sp)+, UISD0
        mov (sp)+, UISA1
        mov (sp)+, UISA0
        mov (sp)+, PS
        rts pc

这就是利用kernel栈作为中介,将同一模式(user模式)下数据进行操作的例子,和clearseg,我们借用了user的S0/S1作为数据的来源和目的.恩,本质来说,还是比较简单的

### savu

savu的原型类似于`void savu(int reg[2]);`,参数是一个寄存器的数组,作用是将当前的sp和r5保存到这个数组中去(一般就是上一篇看到的user.u_rsav).当然,这是它的显式作用,至于为什么要这样设计,这个我们后叙

具体代码见725行:

    _savu:
        bis $340, PS    / pri = 7
        mov (sp)+, r1   / 出栈返回地址,保存到r1
        mov (sp), r0    / 出栈参数(即reg地址),保存到r0
        mov sp, (r0)+   / 一系列赋值
        mov r5, (r0)+
        bic $340, PS    / pri = 0,此处并没有保存,因为没有必要
        jmp (r1)        / 直接跳转

一般我们使用rts或者rtt(中断的时候)来从函数返回,但此处并没有,而是选择了手动的获取返回地址并直接jmp.我们把栈的情况用图说明下:

![savu栈说明][savu]

从上图可以看到,保存的reg[0]为指向参数reg的sp值,我们从一个函数中返回后,sp同样指向类似的位置(即首个参数的位置),然后有调用方进行清栈,所以保存这样的sp是正确的

最后我们使用`jmp`,就是为了避免再次出栈的情况(因为我们已经手动出栈了)

但是否我们只有这么一个方法来做呢?我觉得不见得,其实我们计算出真正的sp值之后赋值给reg即可,没有必要手动处理返回地址出栈的过程.我想,这样做的目的,应该是和下面两个紧跟的函数相对称(这个想法可能是错的..额..)

我们就来看配合的其他两个函数

### aretu, retu

这两个参数的原型类似,都是如`void aretu(int reg[2]); void retu(int reg[2]);`,参数是保存了sp和r5的数组(一般在我们的user.u_rsav或者user.u_ssav等字段),作用是修改现在进程的sp和r5值,唯一的区别在于retu直接修改了kernel的S6,从而造成了进程的切换(还记得S6是指向当前运行进程么?)

具体代码见734行:

    _aretu:
        bis $340, PS
        mov (sp)+, r1
        mov (sp), r0        / 和savu类似,使用r1保存地址,r0保存reg
        br 1f
    _retu:
        bis $340, PS
        mov (sp)+, r1
        mov (sp), KISA6     / 把reg的值赋值给KISA6,这也是为什么user结构最开始必须是u_rsav的原因
        mov $_u, r0         / r0的值为_u的地址,_u指向的同样是KISA6
    1:
        mov (r0)+, sp
        mov (r0)+, r5
        bic $340, PS
        jmp (r1)

看了代码,我们就清楚了,retu直接把reg的地址复制给了S6的PAR,这样S6指向的进程就发生了切换.不过此时的pc还没有改变,所以我们执行的还是原进程的代码.

也许你说,怎么会呢?进程间不是隔离的么?自然,我这里说的,只是指进程的kernel部分,这一部分是进程间共享的(进程切换属于调度范畴,是kernel的功能之一,也就是kernel做的额外事),所以我们切换了S6,但是仍然在原进程的kernel部分继续执行代码.

让我们用图来梳理下:

![retu栈说明][retu]

当我们从retu/aretu返回时,调用方首先清理参数栈,看到了吧,由于savu和retu/aretu的参数是一致的,所以清栈是成功的(参数个数一致,清栈操作一致),这样从retu/aretu返回完全不影响原进程的kernel部分的执行,直到该调用方返回.

此时调用方返回,清理临时变量栈,取得返回地址,更新r5,然后返回.但此时sp和r5变成了原先savu时的sp和r5,此时的清栈变成了类似savu调用方的清栈,然后获取savu调用方的返回地址,这样,我们成功的返回,就相当于从最近一次savu**调用方**返回一致(此时连pc都变了)

为什么是**savu的调用方**?因为我们保存的不是savu的环境,而是手动的退回到了savu调用方的环境,此时再次返回的话,就是从savu的调用方返回.(再看一遍,保证你懂了)

记住一点,参数是调用方环境的一部分,retu的调用方返回时,我们的sp已经指向了savu的调用方,因此此时的返回必然是从savu的调用方返回.

这就是我们要同时保存sp和r5的原因,清理临时变量时需要r5给出清理的终点(一般直接赋值`mov r5, sp`即可),能这样做,是因为这同样是系统的约定,在编译器层面和os的约定,只有这样我们才能完成如此trick的返回.

好吧,最复杂的已经过去了,savu/retu组合用来完成进程的切换.savu可以类比于setjmp,保存当下环境,retu类比于longjmp,跳转回原先保存的地方.当然,这只是类比,savu/retu处理的返回都是和调用方相关的.savu用于保存savu调用方的环境,retu的返回不会异常,但是retu调用方的返回,就是从savu的调用方的返回.等会儿分析到进程切换我们还会详叙.














[savu]: /image/savu.png "savu栈说明"
[retu]: /image/retu.png "retu栈说明"
