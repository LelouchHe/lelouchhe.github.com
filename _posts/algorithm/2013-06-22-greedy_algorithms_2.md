---
layout: post
title: 贪婪算法2
category: algorithm
tag: greedy
---

我们再来看一个类似的问题,来进一步了解贪心算法的另一种解法

## 简单Interval Partitioning问题

我们这里有n个任务,对于每个任务i,都存在一个s_i和f_i,用于表示任务的开始和结束时间,同时,我们有若干机器用于完成这些任务.唯一的条件是重叠的任务不能在同一时间同一机器上处理.亦即,如果i,j两个任务在处理时间上重叠,那么就必须分配在两个不同机器上运行.

问题的目标是在给定n个任务的情况下,如何分配这些任务,使得使用的机器数最少.

## 从上一篇来的解法

我们从[上一篇][greedy algorithms 1]学会了如何使用贪心算法来在一台机器上安排最多的任务,那么一个很自然的想法就是多次运行上述贪心算法,直到所有的任务都完成了.此时的机器数量,就是我们的可能的"最少"机器数量.

我们可以证明这个数量就是"最少"的机器数量.其实也不需要证明,我们这样的处理,得到的显然是最少的机器,不是么?每台机器都被利用到最大限度,所以肯定是最少数量的机器了.

## 优化解法

假设最少机器数量为m,如果按照上面的算法,我们需要执行m次贪心算法,每次算法耗时O(n),那么总的复杂度为O(mn).当然,如果m比较小的话,其实复杂度还是线性的.

但是回顾m次重复的算法,有很多可以利用的东西被忽略了.比如当选择了任务i时,可以得到一系列与i重叠的任务,这些任务都是不能同i在这台机器上处理的.如果按照上面的算法,这些任务就被丢弃了.等到选择下次机器选择的时候,我们还得重新来过.但这些任务是有额外信息的,比如他们是按照f_i排序的,这些任务可以直接使用,因为就算下次来过这些任务的排序之类是不会变的.所以如果我们直接把这些任务安排在下一台机器上,那么我们就可以使用这些信息,来优化复杂度了.

### 算法设计的一个要诀

**额外信息**

这四个字绝对值得单独开辟一个小节来指出.设计算法时,一定要选择和利用所有的信息,而且如果可能的话,一定要深刻的把握住最为关键的信息.

能够揭示问题本质的信息,一般会带来设计或优化算法的思路.

所以睁大眼睛,看清问题

## 另一种解法

上面的算法和书上讲的不太一样,但本质而言,是一致的



[greedy algorithms 1]: /greedy_algorithms_1
