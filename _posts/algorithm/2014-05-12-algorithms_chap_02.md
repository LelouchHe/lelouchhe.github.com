---
layout: math
title: 算法之美第二章
category: algorithm
tag: algorithms
---

## 闲话

第一章的习题,终于在时隔一年多之后完结了,回首解题的过程,感觉十分复杂.这一年來发生了很多事情,再加上自己本来就朝三暮四的性格,导致学习的效率十分的低下

现在决定严格的按照顺序來学习,不再东一下西一下的乱搞,搞到最后,每个都烂尾了

接下来的一段时间,会主攻算法之美这本书(话说中文版真的是学计算机的人翻译的么?),争取是一周一章的节奏,包括知识点总结和习题

至于完成之后干什么,目前还没有好的想法,初步的思路是[算法导论][clrs]或[算法设计][algorithm design]或[算法引论][induction]三选一,或者全搞,最后搞具体数学做补充

好吧,我一下子就把未来一年都铺垫好了,汗

## 概述

本章的重点是分治算法,分治是一种非常重要的算法了,如果广义的来看算法分类,基本所有的算法都可以或多或少的算到分治当中.一旦涉及到问题的分类和问题之间的关系构造与维护,基本就会扯上分治

比如下一章的图的分解,看上去貌似只是图这种数据结构自身的操作,但细想,dfs不也是将问题分解为当前节点和相邻节点两个部分,然后分别解决的么?后面的最短路径,贪心/DP等等,莫过如此

但广义角度谈分治,对实际的操作意义不是很大,所以本章还是挑选了一些非常明显和重要的分治应用的例子,让我们了解这种思想

## 分治的通用步骤

通常,分治分为三个步骤:

1. 将原问题分解为一组与原问题类型相同的子问题,但每个子问题规模比原问题小
2. 递归的求解子问题
3. 将所有子问题的解进行恰当的合并,得到原问题的解

步骤虽简,但如何灵活运用,需要不断的进行总结和练习,现在针对三个步骤,有几个需要特别注意容易忽视的点:

###  分解

作为分治的第一步,首先需要分析原问题是否存在子问题,这个涉及到边界或者初始值,即后面递归终点的判断.只有原问题确实有子问题,且有必要分解時,我们才开始分解,否则,就需要做为原子问题(不可分),充当递归终点

递归求解第一要素是什么?

从我的经验来看,应该是大多数人都不重视的递归终点.类似归纳法一样,递归终点是归纳/递归的起点,可以是问题无法划分,也可以是问题的规模已经可以求解了.没有递归终点,再怎么递归求解都是假的.所以,这个作为分解的第一步,是非常必要的.主要有以下几个思考的方向:

* **从递归终点开始**: 其实思考分治问题的一个角度,或者叫分析所有问题的角度,都是从小case入手,即通过最小的,无法划分的原子问题,來尝试求解整个问题.当然,此处可能还不能称之为"递归终点"(因为还没有要使用递归的意思),但这是一个很好的思考问题的开始,这也暗示,分治法是非常通用的
* **递归终点规模**: 下面会提到问题的规模,这里简单说下,终点不一定是规模最小的问题,相反,终点应该是可以直接求解的问题,"规模"这里只是一个比较常用的衡量问题可解性的指标,但不是唯一的."减小"只是问题的一个方面,也有很多问题是要"增大"到一定规模,才能直接求解的,不要忽视这个方面
* **递归终点个数**: 问题不止有一个递归终点的,比如奇偶性质的问题,一般都有2个递归终点(0/1,或一奇一偶),有些问题的终点case更多,大致的原则就是完全覆盖.当然,在分析问题的开始,可能无法掌握全部终点case,这里只是提醒,不要找到一个终点就沾沾自喜,要同后面的问题分解与递归合并起来,迭代几轮,才能获得正确的理解

然后,在分解的过程中,不要拘泥于常见的二分,即将原问题分解为2个子问题.二分并不是分治的全部,子问题的数量和参数的规模往往取决于原问题的状态,很多情况下,二分是合适的(二分简直就是利器,思考无门,尝试二分),但不是全部,目前遇到过的可能的分法有:

* **常量划分**: 常见的有Fib数列$F _ n = F _ {n - 2} + F _ {n - 1}$,就是将原问题分解为2个子问题,每个子问题的规模都比原问题小了常数而已.其实我们应该比较熟悉这种方式的,惯用的数学归纳法的常见证明,不就是利用$n - 1$推$n$么?此处注意的是,子问题的数量和规模都可能进行常量划分(比如k个子问题,规模小了m之类)
* **全划分**: 常见的有Catalan数$C(n) = \sum _ {i = 0} ^ n {C(i) C(n - i)}$,子问题是所有规模小的问题.这种在数学归纳法中也偶有碰到,即利用全部的子问题,而不只是最接近的子问题.这种划分由于不常见,很容易被忽略,需要特别的注意,如果问题性质确实这样,就要大胆的操作
* **多维划分**: 常见的有lcs(最长公共子串),递归公式就不写出了.虽然这个是属于DP的,但是从更广层面,也是属于分治的.对于多维问题,首先得分析出问题的维度,然后再分析子问题的划分.这类问题往往融合的其他更复杂的性质(比如DP),但分析的方法是一致的
* **倍数划分**: 这个就是最常见的划分了,比如快排$Q(n) = Q(n / 2) + Q(n / 2)$或者更通用的$Q(n) = a Q(n / b)$.a和b不一定相同,这点是容易被忽略而犯错的

在这里罗列这些的目的,并不是让大家遇到问题時一个一个枚举尝试,而是告诉大家,子问题划分的方式是非常多的,也许将来会碰到更复杂,奇怪,甚至恐怖的划分方式,但只要严格分析问题,说明划分的正确性,我们都应该接受.我本人就遇到过类似的情况,一种划分比较罕见,结果就没有勇气分析下去了,但结果证明这种划分是正确的.不要害怕,只要对的,奇怪些无所谓

最后,子问题必须满足的性质是"类型相同,规模减小":

* **类型相同**: 不代表完全一致,有些复杂问题的子问题可能和原问题差距很大,但子问题的进一步划分,即子问题的子问题就类似了,这种"二阶段"的类型相同,也是可以进行划分的(还记得铺地板的题目么?).更复杂的问题可能还有多阶段,或者每个阶段都是不同类型问题的混合,都是有可能的
* **规模减小**: 不代表一定减小,同二阶段分治类似,有时的子问题仅仅是原问题的变换,为进一步划分做准备.当然,最后一定要减小规模,否则怎么解决完毕?

再多嘴一句,"规模减小"其实也只是形象的说法,减小只是递归解决的常见情况而已,小大都是相互的,只要解决问题就可以,不用拘泥于绝对数量

### 递归

重点之一依然是上面提到过的递归终点,不过此时,我们对问题有了进一步的了解,通过分解问题,也明确了最后问题会分解成的规模和类型,此时的递归终点探索在于找到这些case,完善递归终点,或者证明这样的东西不存在,推翻分治的基础,从而让我们尝试其他思路

除了迭代的思考递归终点和问题分解之外,递归求解的过程还有一些其他需要思考和迭代的地方:

* **问题的表示** 承接自问题分解,上一步時,可能不会去思考问题的具体表示,只需要大概的区分子问题即可,但是此处,需要将问题的表示明确下来,更多的从数学表示或实现方面來入手(因为我们要开始解决问题啦).比如需要多少维的表示,有哪些中间变量,递归终点怎么表达,递归终点的结果怎么表达之类的,都是需要在此处给出比较明确的结论的
* **问题的重新分解** 有的时候问题分解的很理想,在此步骤就无法进行下去了,比如分解時我们有一个不通用的假设(不是所有问题都满足的条件之类的),到了这一步无法进行下去了,这时,我们就需要重新分解问题.其实可以看到,这也是一个迭代的过程,两方面都在不同程度上相互改进

问题的重新分解,一是大方向的变化,比如以前沿着思路A展开的,在递归求解時发现了矛盾,那么下一次就可以沿着思路B开始;还有更普遍的情况,我们欠缺的只是一两个性质而已,很多情况下,可以通过增加状态或增加维度來解决(想想那么多的DP问题).主要的提醒点在于一旦无法继续,要能想到这两个方向的补救措施,不要茫然失措

### 合并

合并子问题的难度不定,有的问题合并非常trival,有的则是问题的难点所在(比如平面内最短点对),但此时,与初次遇到问题時相比,我们有几个优势:

* **子问题解** 合并時,我们已经有了子问题的解了(假设中,或已经求得),比一开始什么都不知道的情况有了很大的改善,至少我们有了部分解,一百步走了五十步了
* **问题性质** 不仅对于解,对于问题我们也有了清楚的了解,从基本case(递归终点),问题间递归关系(子问题分解和递归),我们对问题的本质有了进一步的认识

当然,这些优势不代表一定可以解决问题,此处只是给各位打一针预防,不要把合并想的非常简单(大部分情况比较简单),合并的复杂度有可能决定了问题的复杂度,不要找不到简单的合并策略,就直接否定了分治的使用,这样是完全错误的

### 总结

从概述的分析中,可以看到,分治算法的运用,并不是顺序的,而是不停的迭代:

尝试分解 -> 递归表示 + 递归终点 -> 合并 -> 新的分解 -> 新的表示和终点 ->新的合并 ...

这样不断的迭代,不断的掌握问题性质,不断的深挖问题本质,才能得到问题的求解.不要寄希望于一蹴而就,相反,如果真的遇到陌生的问题,不停的试错才可能是正常的解决问题之道

## 分治的理论依据

怎么证明分治的合理呢?其实在我看来,分治的本质就是数学归纳,我们上面讨论的众多情况,其实都在数学归纳法中体现.如果我们数学学的好,见惯众多恶心复杂的利用归纳的问题,那么算法问题其实很微不足道(可惜数学学的一塌糊涂啊..泪奔..)

归纳的关键有2个:

1. 归纳基础,即我们的归纳终点,一个可以验证,可以直接求解的基础问题.
2. 递归关系,即我们的分解+递归+合并,三个步骤都会沾一些,这也说明了分治的三步,其实就是一步而已,只不过分割称三个终点不同的子步骤,方便我们focus攻关的重点而已

归纳是一个非常棒的思路,具体的可以参看[算法引论][induction],通篇都在讲这一个道理

我们上面提到的各种变化,其实都是数学证明/求解的技巧而已,由于不熟悉,所以才觉得非常神奇.所以说,学好数学,很重要

## 主定理

求解完分治问题,在估计复杂度時,有一个主定理是非常方便的

假设一个分治问题的递归关系为:

$$
\left
\\\{
\begin{aligned}
T(n) = a T(n / b) + f(n) \\\\
T(0) = O(1)
\end{aligned}
\right.
\Rightarrow
T(n) = 
\left
\\\{
\begin{aligned}
n ^ {\log _ b a} & \, & n ^ {\log _ b a} = \Omega (f(n)) \\\\
f(n) \log n & \, & n ^ {\log _ b a} = \Theta (f(n)) \\\\
f(n) & \, & n ^ {\log _ b a} = O(f(n))
\end{aligned}
\right.
$$

可以简单的通过画图得到验证(但估计证明过程肯定也很复杂),我们只需要简单的使用即可.看上去复杂,通用的说法就是看子问题求解($n ^ {\log _ b a}$)和合并($f(n)$)哪个更耗时,如果一样的话,就要加$\log n$即可

[clrs]: http://book.douban.com/subject/3904676/ "算法导论"
[algorithm design]: http://book.douban.com/subject/1475870/ "算法设计"
[induction]: http://book.douban.com/subject/1475815/ "算法引论"
