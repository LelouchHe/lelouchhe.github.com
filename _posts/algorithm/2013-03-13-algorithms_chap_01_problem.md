---
layout: math
title: 算法之美第一章 习题
category: algorithm
tag: algorithms
---

## 1.1

b进制数最大n位数为$b ^ n - 1$,所以b进制最大的2位数为$b ^ 2 - 1$,最大1位数为$b - 1$,而
$$
b ^ 2 - 1 \geq 3 (b - 1)
$$
恒成立(移项后化简,且$b \geq 2$)

重点是怎么找到问题关键,并用数学的形式表达

## 1.2

因为$2 ^ 4 - 1 = 15 \gt 9$,所以4位2进制数能表达最大值大于1位10进制数表达的最大值,所以相同数字的2进制数位数不会大于10进制数的4倍(其实等同于比较$2 ^ 4 \gt 10$)

N在b进制下的位数大致为$\log _ b N$,所以2进制位数与10进制位数比大致为$\log _ 2 N / \log _ {10} N = \log _ 2 10$

## 1.3

当d叉树为满树的时候,深度最小(因为最多的节点都被压宽,而没有增加深度),所以有如下公式:
$$
1 + d + d ^ 2 + d ^ 3 + \cdots = \frac{d ^ H - 1}{d - 1} \geq n
$$
求解该方程,即可得到H(深度,为了避免和d冲突所以称为H)的结果$H \geq \log _ d [(d - 1) n + 1]$,即可得到结论

## 1.4

$$\log {n !} = O(\log {n ^ n}) = O(n \log n)$$

$$\log {n !} = \Omega (\log {(\frac{n}{2}) ^ \frac{n}{2}}) = \Omega (\frac{n}{2} \log {\frac{n}{2}}) = \Omega (n \log n)$$

根据Hint来非常容易,需要注意的是,如何省略来简化运算,比如2式中真正算下来会有一项$- n / 2$,但是这项不足以影响到阶($n \log n$),所以可以忽略而没有影响

## 1.5

设
$$
H(n) = 1 / 1 + 1 / 2 + 1 / 3 + 1 / 4 + \cdots = \sum _ {i = 1} ^ n 1 / i
$$
所以
$$H(n) \leq 1 / 1 + 1 / 2 + 1 / 2 + 1 / 4 + \cdots = \Theta (\log n)$$
$$H(n) \geq 1 / 1 + 1 / 2 + 1 / 4 + 1 / 4 + \cdots = \Theta (\log n)$$

不等式右边是根据Hint来的,这样就能很容易看出$H(n) = \Theta (\log n)$

## 1.6

其实P23的乘法算法就是简单的模仿了我们平时进行的竖式乘法,只不过把下一个结果向左移(竖式乘法)变成了左移被乘数(乘法算法),本质上是一致的

## 1.7

根据先前的分析,迭代需要至少n次(每次减少1位,共n位),每次迭代中,可能有加法,这个需要O(max(m, n))次,所以总的时间是O(n max(m, n))

## 1.8

递归的算法一般要利用归纳法来证明.

1. 当$x = 0$时,$(q, r) = (0, 0)$是显而易见的

2. 当$x = 2 k$时,即x为偶数,我们可以看到
$$x = 2 k = y q + r$$
$$x \` = k = y q \` + r \`$$
所以可以看到,$q = 2 q \`, r = 2 r \`$,得证

3. 当$x = 2 k + 1$时,即x为奇数,可以这样来看
$$x = 2 k + 1 = y q + r$$
$$x ' = k = y q ' + r '$$
$$2 x \' = 2 k = y 2 q \' + 2 r \'$$
所以,$q = 2 q \prime, r = 2 r \prime + 1$(注意加1补齐缺少的1,只能r来补).这样没错,但是会产生一个问题,就是$r$可能越来越大(因为只考虑了相等,而没有考虑余数),所以需要特别判断当$r \geq y$的时候,需要做调整

时间复杂度类似于乘法,递归n次,每次O(n),总时间O(n ^ 2)

可以看到,证明很容易,但是要凭空设想出这样精巧的方案,确实很难

递归,抓住结束条件,归纳而上

## 1.9









