---
layout: math
title: 算法之美第一章 习题
category: algorithm
tag: algorithms
---

## 1.1

b进制数最大n位数为$b ^ n - 1$,所以b进制最大的2位数为$b ^ 2 - 1$,最大1位数为$b - 1$,而
$$
b ^ 2 - 1 \geq 3 (b - 1)
$$
恒成立(移项后化简,且$b \geq 2$)

重点是怎么找到问题关键,并用数学的形式表达

## 1.2

因为$2 ^ 4 - 1 = 15 \gt 9$,所以4位2进制数能表达最大值大于1位10进制数表达的最大值,所以相同数字的2进制数位数不会大于10进制数的4倍(其实等同于比较$2 ^ 4 \gt 10$)

N在b进制下的位数大致为$\log _ b N$,所以2进制位数与10进制位数比大致为$\log _ 2 N / \log _ {10} N = \log _ 2 10$

## 1.3

当d叉树为满树的时候,深度最小(因为最多的节点都被压宽,而没有增加深度),所以有如下公式:
$$
1 + d + d ^ 2 + d ^ 3 + \cdots = \frac{d ^ H - 1}{d - 1} \geq n
$$
求解该方程,即可得到H(深度,为了避免和d冲突所以称为H)的结果$H \geq \log _ d [(d - 1) n + 1]$,即可得到结论

## 1.4

$$\log {n !} = O(\log {n ^ n}) = O(n \log n)$$

$$\log {n !} = \Omega (\log {(\frac{n}{2}) ^ \frac{n}{2}}) = \Omega (\frac{n}{2} \log {\frac{n}{2}}) = \Omega (n \log n)$$

根据Hint来非常容易,需要注意的是,如何省略来简化运算,比如2式中真正算下来会有一项$- n / 2$,但是这项不足以影响到阶($n \log n$),所以可以忽略而没有影响

## 1.5

设
$$
H(n) = 1 / 1 + 1 / 2 + 1 / 3 + 1 / 4 + \cdots = \sum _ {i = 1} ^ n 1 / i
$$
所以
$$H(n) \leq 1 / 1 + 1 / 2 + 1 / 2 + 1 / 4 + \cdots = \Theta (\log n)$$
$$H(n) \geq 1 / 1 + 1 / 2 + 1 / 4 + 1 / 4 + \cdots = \Theta (\log n)$$

不等式右边是根据Hint来的,这样就能很容易看出$H(n) = \Theta (\log n)$

## 1.6

其实P23的乘法算法就是简单的模仿了我们平时进行的竖式乘法,只不过把下一个结果向左移(竖式乘法)变成了左移被乘数(乘法算法),本质上是一致的

## 1.7

根据先前的分析,迭代需要至少n次(每次减少1位,共n位),每次迭代中,可能有加法,这个需要O(max(m, n))次,所以总的时间是O(n max(m, n))

## 1.8

递归的算法一般要利用归纳法来证明.

1. 当$x = 0$时,$(q, r) = (0, 0)$是显而易见的

2. 当$x = 2 k$时,即x为偶数,我们可以看到
$$x = 2 k = y q + r$$
$$x ' = k = y q ' + r '$$
所以可以看到,$q = 2 q ', r = 2 r '$,得证

3. 当$x = 2 k + 1$时,即x为奇数,可以这样来看
$$x = 2 k + 1 = y q + r$$
$$x ' = k = y q ' + r '$$
$$2 x ' = 2 k = y \cdot 2 q ' + 2 r '$$
所以,$q = 2 q ', r = 2 r ' + 1$(注意加1补齐缺少的1,只能r来补).这样没错,但是会产生一个问题,就是$r$可能越来越大(因为只考虑了相等,而没有考虑余数),所以需要特别判断当$r \geq y$的时候,需要做调整

时间复杂度类似于乘法,递归n次,每次O(n),总时间O(n ^ 2)

可以看到,证明很容易,但是要凭空设想出这样精巧的方案,确实很难

递归,抓住结束条件,归纳而上

## 1.9

由$x \equiv x ' \mod N$可知$x - x ' = a N$,同理$y - y ' = b N$,二式相加,得$(x + y) - (x ' + y ') = (a + b) N$,这样就能得到题目$x + y \equiv x ' + y ' \mod N$

## 1.10

因为$x \equiv y \mod N$, 所以$x - y = a N$, 又因为$N = b M$, 二式比较得$x - y = a b M$, 所以$a \equiv b \mod M$

## 1.11

刚才看错了,以为是$\mod 5$,我就说怎么这么简单

$$4 ^ 1536 = (4 ^ 3) ^ 512 = 64 ^ 512 \equiv (-6) ^ 512 = (6 ^ 2) ^ 256 = 36 ^ 256 \equiv 1 \mod 35$$

$$9 ^ 4824 = (9 ^ 3) ^ 1608 = 729 ^ 1608 \equiv (-6) ^ 1608 = (6 ^ 2) ^ 804 = 36 ^ 804 \equiv 1 \mod 35$$

所以$4 ^ 1536 \equiv 9 ^ 4824 \mod 35$

ps:这种问题怎么凑?我们利用的性质是
$$a \equiv b \mod N, c \equiv d \mod N \Rightarrow a + c \equiv b + d \mod N, a c \equiv b d \mod N$$
这个性质的主要利用点是找到同余项,比如此处的$4 ^ 1536$和$9 ^ 4824$

如果是我之前看到的$\mod 5$,那么4和9本身就满足条件(都余4),但$\mod 35$,我们就需要其他的项,一般是试错性质的比较次幂的同余,逐步来得到最终的结果

## 1.12

$$
2 ^ {2 ^ 2006} = (2 ^ 2) ^ {2 ^ 2005} = 4 ^ {2 ^ 2005} \equiv 1 ^ {2 ^ 2005} = 1 \mod 3
$$

从解这两道题,我们可以看到,1在$\mod$运算中的地位,因为1不论怎么计算,最终结果都是1,所以在求解类似题目的时候,要首先往1方向靠

## 1.13

$$5 ^ 30000 = (5 ^ 3) ^ 10000 = 125 ^ 10000 \equiv 1 \mod 31$$

$$6 ^ 123456 = (6 ^ 3) ^ 41152 = 216 ^ 41152 \equiv (-1) ^ 41152 = 1 ^ 41151 = 1 \mod 31$$

所以二者之差$\mod 31$为0,即可以整除31

看,仍然是凑1战术,1非常有特殊性,0的话是整除,这个比较好看,对于不好看的取模,找1是比较妥当的

## 1.14





