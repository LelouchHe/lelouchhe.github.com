---
layout: math
title: 算法之美第一章
category: algorithm
tag: algorithms
---

## 闲话

这个本来是要写在做完习题之后的,但是突然发现,第一章看了很久,很多知识都忘记了,所以决定改变策略.本来在公司看的书就无法保证连续性,题目真的很难的话,书会看很久,题目也会拖很久才能搞定.这样远不如看完一章,总结一章,不仅避免了到时候重新再看一遍书的问题,而且遇到疑问可以直接看总结,能省不少时间

这里主要记录了本章的主要知识点,和看书时的一些思考

## 概述

本章的主要内容其实是初步的数论,分析了四则运算和模运算的简单算法和复杂度分析,接着讲了数论在计算机上最成功的应用,加密/解密,并说明了其中的原因,即判断一个数是否为质数和对一个数进行质因数分解两种类似运算之间天差地别的复杂度瓶颈

还介绍了设计求解算法中的几个时刻思考的问题:

1. 这样做为什么是对的?
2. 这样做的时间复杂度如何?
2. 有更快的算法么?
3. 怎么证明这个算法是对的?

往往一个问题的定义可以作为问题的初步算法解,但这也一般是trival的,没有突出问题关键的算法.好的算法,其实不在于多么精巧,而是要充分的利用问题的特性,越抓住本质,越接近本质,才能得到更快更好的算法

## 四则运算

### 加法和减法

加法减法的算法本质都是trival的单纯按照定义的运算,即按照位,从低到高依次计算.唯一有些麻烦的地方在于最高位,我们需要证明最高位加减的结果,确实在常数范围内(否则就不可控的超过n了),而下面这个定理就是说明这个的:

三个一位数相加,结果最大不超过两位数(证明见习题1.1)

这样,我们计算的过程,就不会超过运算数字的位数了.当运算数字为N时,其位数不会超过$n = \log N$,而我们的复杂度也就是$O(n) = O(\log N)$

后文我们处理复杂度,直接利用其位数n(因为这才是我们计算的本质,按位计算)

### 乘法和除法

乘法的初级算法也是按位来乘,可以想象,假设相乘的数字位数为n,一位数的乘法复杂度为$O(1)$,那么每次乘数的一位进行的运算复杂度就是$nO(1) = O(n)$,这样的计算最多需要n次(因为有n位),所以总的复杂度为$nO(n) = O(n ^ 2)$

这种算法我们非常熟悉了,以至于我们有时忽略了很多东西,比如竖式计算中,我们将乘数结果写在该乘数位的下方,为什么?其实这就相当于移位.比如$x \cdot 123$,我们计算的其实是$x \cdot 100 + x \cdot 20 + x \cdot 3$,写在下方的目的就是补足没有写出的0,但其实这个移位我们可以换种方式做,这就是书中介绍的Al Khwarizmi的算法,被乘数左移(而不是乘数左移),乘数右移(最低位已经计算完了,所以丢弃),其实本质是一致的,但是这引入了一个很经典的样式,即下面的公式:

$$
x \cdot y = 
\left
\\\{
\begin{aligned}
2 (x \cdot (y / 2)) & \, & y = 2 k \\\\
x + 2 (x \cdot (y / 2)) & \, & y = 2 k + 1
\end{aligned}
\right.
$$

$y = 2 k + 1$时为什么加$x$,其实想想二进制乘法即可,$y$为奇数时,最后位为1,相乘得原结果;为偶数时,最后位为0,相乘为0,就是这么简单.

此时的复杂度比较好分析,每次最多为$O(n)$,总共n次(y每次减半,最多能减n次而已),复杂度还是$O(n ^ 2)$

除法本质上也是利用我们新引入的结论来完成的,具体证明见习题1.8

我们再次回过头来看看新引入的公式有什么特殊启发.我们在定义加法减法乘法除法时,都是利用的无法方便操作的"无限"说法,比如按位加一直"无限"加/减/乘/除到最高位.这个东西在计算机中是很难具体化的(四则运算太简单了,所以可以),计算机更愿意,或者有能力处理小的东西(甚至小于word之后,四则都是一条指令而已),这就带来了我们的新思想,**递归减小**.

我们的新公式其实就做了一件事情,把问题化小,然后解决小问题,小问题不是无限小(因为自然数的关系),我们最终有一个递归终结的最小条件.让我把新公式补全:

$$
x \cdot y = 
\left
\\\{
\begin{aligned}
2 (x \cdot (y / 2)) & \, & y = 2 k \\\\
x + 2 (x \cdot (y / 2)) & \, & y = 2 k + 1 \\\\
0 & \, & y = 0 (终结条件)
\end{aligned}
\right.
$

没有第三个规则,我们是无法完成计算的,而这,才是新公式的启发.**递归减小**是我随口胡说的名称,你可以把这个看作**分治**的一个小例子,但思想是一致的:

**划分小问题,解决最小问题,然后合并问题**

## 模运算

模运算其实和除法有些联系,首先要知道的是取模是个$O(n ^ 2)$的操作(和除法一致,除法能获得商和对应余数),其次就是比较重要的性质:

$$x \equiv x ' \mod N, y \equiv y ' \mod N \Rightarrow x + y \equiv x ' + y ' \mod N, x y \equiv x ' y ' \mod N$$

还有交换律,结合律,分配律等.

当我们无法判断的时候,回归定义是不错的选择,因为模就是余的另一种表达方式,无法在模中证明的性质,可以跳出来回到除法余数的角度来看.

模运算说白了就是简化运算集大小的运算(限制在0~N-1),将不同的数组成了**群**(内部对加乘封闭)

### 模加和模乘

模加和模乘并没有什么精巧的算法,唯一需要注意的是,如果我们在进行多于两个数的加/乘,可以及时的使用上面的模性质,计算出一个中间结果就取模,这样可以大大的减小中间结果的大小,也带来一个好处,即所有的结果均在0~N-1之间(这是废话),保证我们的算法分析只需要考虑N的情况即可.

此时,模加的复杂度$O(n)$,模乘的复杂度$O(n ^ 2)$

### 模指运算

模指运算是指计算形如$x ^ y \mod N$的运算,在加密/解密中需要大量这样的运算(具体过程后叙).其实看到乘方,很容易想到一种经典的拆分方法

$$
x ^ y \mod N = 
\left
\\\{
\begin{aligned}
(x ^ {y / 2}) ^ 2 \mod N & \, & y = 2 k \\\\
x \cdot (x ^ {y / 2}) ^ 2 \mod N& \, & y = 2 k + 1 \\\\
1 & \, & y = 0
\end{aligned}
\right.
$$

之所以想到这个,我们不能仅从以前遇到的经典拆分来看,因为形式是次要的,思想本质才最重要.

这样做的原因在于,如果我们真的按照一次一次的乘起来,我们会浪费非常多的中间结果,比如计算了$x ^ 2$之后,我就可以直接算$x ^ 4 = (x ^ 2) ^ 2$了,而不是再继续乘2次x.可以看到,如果我们不对整个结果做保留,只保留最近的一次结果和原始的x的话,这样做显然比单一的乘法要好.

具体的复杂度来说,我们总共会进行$\log y$次迭代,每次相乘的数字不大于N(因为取模了,其实应该是不大与max(x, N)),相乘取模复杂度为$O((\log N) ^ 2)$,所以复杂度为$\log y O((\log N) ^ 2) = O(\log y (\log N) ^ 2) = O(n ^ 3)$

我们换一个思路来看,$x ^ {25} = x ^ {11001_2} = x ^ {10000_2} \cdot x ^ {1000_2} \cdot x ^ {1_2} = x ^ 16 \cdot x ^ 8 \cdot x$,我们只需要观察25的2进制表示,就能知道如何计算25次幂最为迅速,看结果,我们其实只需要$x, x ^ 8, x ^ 16$即可,而需要哪个不需要哪个正是从25的位为1为0来判断.

这种思路得到的结果应该和上面一致,只不过上面是从大问题划分为小问题最后终结,而现在是从小问题推到大问题.最后在实现层面上,应该只是一个是递归,一个是循环的差别,但殊途同归

我们应该熟悉不同的思路

### 最大公约数

gcd的经典算法来源于一个公式$gcd(x, y) = gcd(x \mod y, y), x \geq y$

证明如下:(注意公约数和最大公约数的区别)
1. $gcd(x, y) \leq gcd(x - y, y)$: 能被x,y整除的,肯定也能被x-y整除(即x,y的最大公约数肯定也是x-y,y的公约数)
2. $gcd(x, y) \geq gcd(x - y, y)$: 能被x-y,y整除的,肯定也能被x整除(即x-y,y的最大公约数,肯定也是x,y的公约数)
3. $x \mod y$能通过$x - y$多次来获得,所以结论成立

这里反复使用了公约数和最大公约数的不同,来夹最后的答案,这是一个很有用的技巧(夹逼准则)

既然这样,我们很容易得到gcd的计算公式($x \geq y$)

$$
gcd(x, y) = 
\left
\\\{
\begin{aligned}
x & \, & y = 0 \\\\
gcd(y, x \mod y) & \, & y \neq 0
\end{aligned}
\right.
$$
($x \mod y \leq y$,所以会调换位置)

我们可以尝试分析下复杂度,每次迭代,y的值都会减小(至少减1),迭代中每次求模复杂度为$O(n ^ 2)$(n为位数),所以其复杂度上限为$y O(n ^ 2))$,不过这个分析不够好,没有分析到底层

因此还有一个定理$a \geq b \Rightarrow a \mod b < a / 2$(这个定理很好证明,分情况讨论b与$a / 2$的大小即可),这个就证明了gcd的参数至少在每次迭代中减少1位.两个数总共2n位,所以迭代最多2n次,复杂度成了$O(n ^ 3)$










