---
layout: math
title: 算法之美第一章
category: algorithm
tag: algorithms
---

## 闲话

这个本来是要写在做完习题之后的,但是突然发现,第一章看了很久,很多知识都忘记了,所以决定改变策略.本来在公司看的书就无法保证连续性,题目真的很难的话,书会看很久,题目也会拖很久才能搞定.这样远不如看完一章,总结一章,不仅避免了到时候重新再看一遍书的问题,而且遇到疑问可以直接看总结,能省不少时间

这里主要记录了本章的主要知识点,和看书时的一些思考

## 概述

本章的主要内容其实是初步的数论,分析了四则运算和模运算的简单算法和复杂度分析,接着讲了数论在计算机上最成功的应用,加密/解密,并说明了其中的原因,即判断一个数是否为质数和对一个数进行质因数分解两种类似运算之间天差地别的复杂度瓶颈

还介绍了设计求解算法中的几个时刻思考的问题:

1. 这样做为什么是对的?
2. 这样做的时间复杂度如何?
2. 有更快的算法么?
3. 怎么证明这个算法是对的?

往往一个问题的定义可以作为问题的初步算法解,但这也一般是trival的,没有突出问题关键的算法.好的算法,其实不在于多么精巧,而是要充分的利用问题的特性,越抓住本质,越接近本质,才能得到更快更好的算法

## 四则运算

### 加法和减法

加法减法的算法本质都是trival的单纯按照定义的运算,即按照位,从低到高依次计算.唯一有些麻烦的地方在于最高位,我们需要证明最高位加减的结果,确实在常数范围内(否则就不可控的超过n了),而下面这个定理就是说明这个的:

三个一位数相加,结果最大不超过两位数(证明见习题1.1)

这样,我们计算的过程,就不会超过运算数字的位数了.当运算数字为N时,其位数不会超过$n = \log N$,而我们的复杂度也就是$O(n) = O(\log N)$

后文我们处理复杂度,直接利用其位数n(因为这才是我们计算的本质,按位计算)

### 乘法和除法

乘法的初级算法也是按位来乘,可以想象,假设相乘的数字位数为n,一位数的乘法复杂度为$O(1)$,那么每次乘数的一位进行的运算复杂度就是$nO(1) = O(n)$,这样的计算最多需要n次(因为有n位),所以总的复杂度为$nO(n) = O(n ^ 2)$

这种算法我们非常熟悉了,以至于我们有时忽略了很多东西,比如竖式计算中,我们将乘数结果写在该乘数位的下方,为什么?其实这就相当于移位.比如$x \cdot 123$,我们计算的其实是$x \cdot 100 + x \cdot 20 + x \cdot 3$,写在下方的目的就是补足没有写出的0,但其实这个移位我们可以换种方式做,这就是书中介绍的Al Khwarizmi的算法,被乘数左移(而不是乘数左移),乘数右移(最低位已经计算完了,所以丢弃),其实本质是一致的,但是这引入了一个很经典的样式,即下面的公式:

$$
x \cdot y = 
\left
\\\{
\begin{aligned}
2 (x \cdot (y / 2)) & \, & y = 2 k \\\\
x + 2 (x \cdot (y / 2)) & \, & y = 2 k + 1
\end{aligned}
\right.
$$

$y = 2 k + 1$时为什么加$x$,其实想想二进制乘法即可,$y$为奇数时,最后位为1,相乘得原结果;为偶数时,最后位为0,相乘为0,就是这么简单.

此时的复杂度比较好分析,每次最多为$O(n)$,总共n次(y每次减半,最多能减n次而已),复杂度还是$O(n ^ 2)$

除法本质上也是利用我们新引入的结论来完成的,具体证明见习题1.8

我们再次回过头来看看新引入的公式有什么特殊启发.我们在定义加法减法乘法除法时,都是利用的无法方便操作的"无限"说法,比如按位加一直"无限"加/减/乘/除到最高位.这个东西在计算机中是很难具体化的(四则运算太简单了,所以可以),计算机更愿意,或者有能力处理小的东西(甚至小于word之后,四则都是一条指令而已),这就带来了我们的新思想,**递归减小**.

我们的新公式其实就做了一件事情,把问题化小,然后解决小问题,小问题不是无限小(因为自然数的关系),我们最终有一个递归终结的最小条件.让我把新公式补全:

$$
x \cdot y = 
\left
\\\{
\begin{aligned}
2 (x \cdot (y / 2)) & \, & y = 2 k \\\\
x + 2 (x \cdot (y / 2)) & \, & y = 2 k + 1 \\\\
0 & \, & y = 0 (终结条件)
\end{aligned}
\right.
$

没有第三个规则,我们是无法完成计算的,而这,才是新公式的启发.**递归减小**是我随口胡说的名称,你可以把这个看作**分治**的一个小例子,但思想是一致的:

**划分小问题,解决最小问题,然后合并问题**

## 模运算

模运算其实和除法有些联系,首先要知道的是取模是个$O(n ^ 2)$的操作(和除法一致,除法能获得商和对应余数),其次就是比较重要的性质:

$$x \equiv x ' \mod N, y \equiv y ' \mod N \Rightarrow x + y \equiv x ' + y ' \mod N, x y \equiv x ' y ' \mod N$$

还有交换律,结合律,分配律等.

当我们无法判断的时候,回归定义是不错的选择,因为模就是余的另一种表达方式,无法在模中证明的性质,可以跳出来回到除法余数的角度来看.

模运算说白了就是简化运算集大小的运算(限制在0~N-1),将不同的数组成了**群**(内部对加乘封闭)

### 










