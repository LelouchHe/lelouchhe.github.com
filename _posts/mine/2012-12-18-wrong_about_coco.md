---
layout: post
title: 关于coco的误解
category: mine
tag: mroutine, lua
---

## 统计错误

今天本来打算放弃mroutine的开发,觉得和pthread线程切换没得比,但是看过[一篇文章][compare coroutine],看到了我自己统计的错误,其实mroutine的性能是我统计的4倍,也就是400万级别的,这个性能就和Lua自己的coroutine差不多(虽然很惭愧的..不过对于第一次实现也不错了..),介于这个ucontext的庞然大物,我觉得汇编还是有前途的,至少最后能超过Lua

## 关于coco

本来我以为coco的没有保存全部的寄存器值,所以状态的恢复是不完全的,但在深入了解嵌入汇编之后,我发现了coco对于clobber的运用,也就是说,coco使用到的寄存器只有少数的4个左右,但是其他的4/12个都保存在了用户的栈上,然后利用swap之后的自动栈恢复操作,把所有的寄存器都恢复,这样就巧妙的还原了现场,同时尽可能少的进行了上下文切换.

非常巧妙的思路,我的汇编版本也可以做如此的尝试,这样至少可以可以减少90%,估计性能会很高

## 返回上下文

这个在我看到的全部coroutine实现中都没有,都是返回即退出,这个我必须实现,就算是借鉴glibc也要实现,因为我觉得这点的便利是非常重要的(虽然我觉得最后会写纯汇编了..)

同时,还要提炼精简的上下文原语,没必要完全按照ucontext那套来做,因为ucontext暴露了ss_stack和uc_link,我不想这样拖垮我的各种版本的通用性

## 总结

燃起吧,这周结束之前,一定要实现千万级别的mroutine,争取上亿,实现了我就自己请客吃一顿大餐,也能弥补这周比较萎靡的精神状态吧

[compare coroutine]: http://www.blogjava.net/killme2008/archive/2010/03/02/314264.html "coroutine比较"
