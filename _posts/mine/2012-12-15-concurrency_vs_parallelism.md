---
layout: post
title: 并发和并行
category: mine
tag: design
---

## 推荐阅读

强烈推荐Rob Pike大牛的[slide][concurrency is not parallelism],这个slide解决了我很多的问题

## 我的理解

举个去饭店吃饭的例子,有这样一家饭店,总共只有一个员工S1,兼任服务员和厨师,那么去这家饭店吃饭肯定是如下的流程:A顾客来了,给A点餐,然后去厨房做饭,把菜端出来给A,然后接着处理顾客B,再然后处理顾客C.

这样的饭店不多,反正我是没有遇到过,这样做的一个很大的缺点就是每次都只能服务一位顾客,剩下的顾客都**block**在了吃饭的第一步上(即点餐),显然的,顾客的吃饭时间除了真正给他服务做饭的时间外,还有他等待前面顾客服务完毕的时间,这样做显然很难让顾客满意.

恰巧在这个时候,老板又招来了一个人S2,如何分配这个新员工,就有不同的做法了

### 做法一

S2执行和S1同样的工作,给顾客点餐,然后去厨房做饭,然后端回来给顾客.

这样做能不能提高服务的效率呢?

答案是**不一定**.

如果这家饭店的厨房只有一套厨具,那么还是每次只能有一个顾客用餐,但是这个时候等待的人群中有了分类,大多数顾客还是**block**在了吃饭的第一步点餐上,而只有一个顾客是**block**在了点餐完毕上菜的过程中.这样做显然稍微提高了点工作的效率,因为这样保证了至少厨房是比较忙的,顾客A的饭做好了,就得开始做B的饭,而无需等待B来点餐,这样虽然处理问题的时间没有变(点餐+做饭),但是等待的时间减少了(以前得等一个循环,现在至少有一个顾客只是等厨房空闲而已),使得饭店单位时间能够处理的问题变多了,提高了所谓的**吞吐量**

还有一种情况,这家饭店有两套餐具,那么提升就比较明显了,顾客A和顾客B基本可以同时吃饭了,因为S1和S2的服务并不冲突,二者可以同时进行,这样至少顾客B就无需等待顾客A的饭做好了,这个时候其实大多数人还是**block**了第一步,但是B却可以像第一个来吃饭的A一样,享受到无等待服务了.这样的好处和第一种情况类似,等待时间少了(没有顾客会等待厨房空间了,大家都是排队时间了)

可以看到,两种情况其实都可以增加单位时间处理顾客的数量,但处理单位问题的时间并没有增长,它减少的仅仅是等待时间而已.

### 做法二

新员工还可以有另一种用法,比如S1继续做他的服务员专门负责点餐,而S2来做厨师,专门负责做饭

现在的情况怎么样呢?厨房外的情况是A来了,S1给A点餐,把菜单传给S2;B来了,S1给B点餐,把菜单传给S2.厨房里就是S2接到菜单,做饭,送到门口传给S1,然后继续接菜单,继续做饭.

这样做能不能提高服务的效率呢?

答案是**不一定**

可以看到,现在所有顾客**block**的时间段分成了两段(而不像前面那些人,特定时间绝大多数等待的阶段都是一样的),一个是等待点餐(S1),一个是等待上餐(S2),如果处理能力不够,其实还是要等的,不过等归等,按照这样层次的划分,至少有一部分的顾客的等待时间减少了(因为他们直接等在了上餐上),而另一部分等待点餐的时间也少了(S1服务完刚才的人,不就可以直接来服务这些人了么),处理问题的时间仍然没有变,但是整体等待的时间减少了,和做法一一样,吞吐量上来了,等待时间减少了,但处理问题仍旧那样.

但情况是否真如这么美好呢?显然不是,因为我们不知道这两个服务段各自的特性,如果点餐远远慢于做饭,那么S1肯定会忙碌到要死,而S2肯定会闲到爆;如果点餐远远快于做饭,那么二者的情况恰好相反.这样的情况维持不了多久,劳累的一方肯定会要求涨工资的(要不就直接走人了),而且如果两个阶段的差距非常之大,以至于可以忽略掉耗时小的阶段,那么我们就又回到了开头的情况--一个服务员的悲催饭店












[concurrency is not parallelism]: https://concur.rspace.googlecode.com/hg/talk/concur.html#landing-slide "并发和并行"
