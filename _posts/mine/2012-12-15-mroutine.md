---
layout: post
title: mroutine库
category: mine
---

## 介绍

这篇文章的主要目的就是描述我准备实现的cotoutine库,具体的要求见[设计一套cotoutine库](/coroutine_code),简而言之就是:

1. asymmetric的coroutine库
2. 结合pthread库,实现多线程和cotoutine
3. 实现类似Go的channel
4. 匿名函数和闭包

## 平台选择

在这里,我没有很关心可移植性,我觉得这个问题可以延后考虑,目前是要开发一套可在我机器上跑的库即可,即x86-64,最多再支持下x86系统即可,别的平台不管了

编译器的话,应该是gcc,版本是4以上(因为公司的gcc很老,貌似是4.1好像)

## 实现样版

经过一定时间的考察和研究,仅仅关于coroutine这部分,我觉得LuaJit的[Coco][coco]非常的不错,有很多借鉴的地方,比如routine的状态保存这部分,我觉得完全可以使用修改之后的Coco版本,在此感谢[SuperMike][mike]带给我们的如此精彩的实现

## 实现第一步

目前已经实现了第一步,即简单coroutine的实现,这部分是利用ucontext的,不过确实如众人所言,ucontext确实很慢,也就是每秒百万级别的切换率(一开始测试错了,所以得到了**惊人**的结果..哎..)

代码参见[mroutine][mroutine]

目前有这样一个疑问没有解决,即routine的提前结束,比如:

    void test_2(struct mroutine_t *mr, int para)
    {
        int i = 0;
        while (i++ < 5)
            mr_yield(mr, para + i);
    }

    void test_1(struct mroutine_t *mr)
    {
        mid_t mid = mr_create(mr, test_2);
        int para = 100;
        mr_resume(mr, mid, para);
    }

当test_2yield的时候,test_2其实没有结束,但是回到test_1之后,test_1立即结束了,而且test_2这个routine对外面是透明的,test_1的调用者无法得知test_2的存在,那么这样,test_2就泄露了.

当然,最后mr_fini的时候肯定会回收的,但是1.如果这是服务器程序,很久才fini;2.test_2动态分配的资源在fini的时候都不会收回(仅有程序结束的时候才会)

目前的解决办法只有避免这种情况的发生,一定要保证上层一定比下层执行的长,而且如果要动态分配资源,一定要保证释放

(额..要不要再做个C版的GC呢..这个就一下全解决了..)

## 实现第二步

现在要做的是提高下性能,准备把ucontext替换成汇编代码,如果有超过5~10倍的提升,就加入主干代码,并给出相应编译选项来

ps: 其实还很想实现可变参数,不过感觉有点难,va能解析的只有int,double而已,指针什么的都是利用两个int模拟出来的(64/32不同),如果都传入的只有指针的话还是可以一试的.恩,等搞定汇编就来做这个.我还很想尝试下多值返回的实现,不过这个在编译器端应该很好弄,在C上的话,可能还得弄清栈结构来进行汇编.好吧,也尝试下吧,不过这就得改变熟悉的调用语法了.

## 重大挫折

汇编好难啊,尤其是各种调用各种寄存器绕来绕去一下子就晕了,整了一天,才只能做到简单的切换,还不能做到函数返回后继续运行.

好吧,我准备抄glibc的实现呀(不过..我不想..)

其实怎么说呢,汇编其实也不好,因为升了很多状态量,很容易引起莫名其妙的bug的,要不我就先ucontext的吧..

[coco]: http://coco.luajit.org/index.html "Coco"
[mike]: http://luajit.org/index.html "SuperMike"
[mroutine]: https://github.com/LelouchHe/mroutine "MRoutine"

